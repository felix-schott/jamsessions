// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package dbutils

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	geom "github.com/twpayne/go-geom"
)

const deleteJamSessionById = `-- name: DeleteJamSessionById :exec
DELETE FROM london_jam_sessions.jamsessions
WHERE session_id = $1
`

func (q *Queries) DeleteJamSessionById(ctx context.Context, sessionID int32) error {
	_, err := q.db.Exec(ctx, deleteJamSessionById, sessionID)
	return err
}

const deleteVenueById = `-- name: DeleteVenueById :exec
DELETE FROM london_jam_sessions.venues
WHERE venue_id = $1
`

func (q *Queries) DeleteVenueById(ctx context.Context, venueID int32) error {
	_, err := q.db.Exec(ctx, deleteVenueById, venueID)
	return err
}

const deleteVenueByJamSessionId = `-- name: DeleteVenueByJamSessionId :exec
DELETE FROM london_jam_sessions.venues l
USING london_jam_sessions.jamsessions s
WHERE s.venue = l.venue_id AND s.session_id = $1
`

func (q *Queries) DeleteVenueByJamSessionId(ctx context.Context, sessionID int32) error {
	_, err := q.db.Exec(ctx, deleteVenueByJamSessionId, sessionID)
	return err
}

const getAllSessions = `-- name: GetAllSessions :many
SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0)::real AS rating FROM london_jam_sessions.jamsessions s
JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
GROUP BY s.session_id, l.venue_id
`

type GetAllSessionsRow struct {
	SessionID         int32              `json:"session_id"`
	SessionName       string             `json:"session_name"`
	Venue             int32              `json:"venue"`
	Genres            []string           `json:"genres"`
	StartTimeUtc      pgtype.Timestamptz `json:"start_time_utc"`
	Interval          string             `json:"interval"`
	DurationMinutes   int16              `json:"duration_minutes"`
	Description       string             `json:"description"`
	SessionWebsite    *string            `json:"session_website"`
	DtUpdatedUtc      pgtype.Timestamptz `json:"dt_updated_utc"`
	VenueID           int32              `json:"venue_id"`
	VenueName         string             `json:"venue_name"`
	AddressFirstLine  string             `json:"address_first_line"`
	AddressSecondLine *string            `json:"address_second_line"`
	City              string             `json:"city"`
	Postcode          string             `json:"postcode"`
	Geom              interface{}        `json:"geom"`
	VenueWebsite      *string            `json:"venue_website"`
	Backline          []string           `json:"backline"`
	VenueComments     []string           `json:"venue_comments"`
	VenueDtUpdatedUtc pgtype.Timestamptz `json:"venue_dt_updated_utc"`
	Rating            float32            `json:"rating"`
}

func (q *Queries) GetAllSessions(ctx context.Context) ([]GetAllSessionsRow, error) {
	rows, err := q.db.Query(ctx, getAllSessions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllSessionsRow
	for rows.Next() {
		var i GetAllSessionsRow
		if err := rows.Scan(
			&i.SessionID,
			&i.SessionName,
			&i.Venue,
			&i.Genres,
			&i.StartTimeUtc,
			&i.Interval,
			&i.DurationMinutes,
			&i.Description,
			&i.SessionWebsite,
			&i.DtUpdatedUtc,
			&i.VenueID,
			&i.VenueName,
			&i.AddressFirstLine,
			&i.AddressSecondLine,
			&i.City,
			&i.Postcode,
			&i.Geom,
			&i.VenueWebsite,
			&i.Backline,
			&i.VenueComments,
			&i.VenueDtUpdatedUtc,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllSessionsAsGeoJSON = `-- name: GetAllSessionsAsGeoJSON :one
WITH t AS (
    SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0)::real AS rating FROM london_jam_sessions.jamsessions s
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    GROUP BY s.session_id, l.venue_id
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

func (q *Queries) GetAllSessionsAsGeoJSON(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRow(ctx, getAllSessionsAsGeoJSON)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getAllVenuesAsGeoJSON = `-- name: GetAllVenuesAsGeoJSON :one
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(v.*)::json)
) FROM london_jam_sessions.venues v
`

func (q *Queries) GetAllVenuesAsGeoJSON(ctx context.Context) ([]byte, error) {
	row := q.db.QueryRow(ctx, getAllVenuesAsGeoJSON)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getCommentsBySessionId = `-- name: GetCommentsBySessionId :many
SELECT c.comment_id, c.session, c.author, c.content, c.dt_posted, r.rating FROM london_jam_sessions.comments c
LEFT OUTER JOIN london_jam_sessions.ratings r ON c.comment_id = r.rating_id
WHERE c.session = $1
`

type GetCommentsBySessionIdRow struct {
	CommentID int32              `json:"comment_id"`
	Session   int32              `json:"session"`
	Author    string             `json:"author"`
	Content   string             `json:"content"`
	DtPosted  pgtype.Timestamptz `json:"dt_posted"`
	Rating    *int16             `json:"rating"`
}

func (q *Queries) GetCommentsBySessionId(ctx context.Context, session int32) ([]GetCommentsBySessionIdRow, error) {
	rows, err := q.db.Query(ctx, getCommentsBySessionId, session)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetCommentsBySessionIdRow
	for rows.Next() {
		var i GetCommentsBySessionIdRow
		if err := rows.Scan(
			&i.CommentID,
			&i.Session,
			&i.Author,
			&i.Content,
			&i.DtPosted,
			&i.Rating,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionById = `-- name: GetSessionById :one
SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
WHERE s.session_id = $1
GROUP BY s.session_id, l.venue_id
`

type GetSessionByIdRow struct {
	SessionID         int32              `json:"session_id"`
	SessionName       string             `json:"session_name"`
	Venue             int32              `json:"venue"`
	Genres            []string           `json:"genres"`
	StartTimeUtc      pgtype.Timestamptz `json:"start_time_utc"`
	Interval          string             `json:"interval"`
	DurationMinutes   int16              `json:"duration_minutes"`
	Description       string             `json:"description"`
	SessionWebsite    *string            `json:"session_website"`
	DtUpdatedUtc      pgtype.Timestamptz `json:"dt_updated_utc"`
	VenueID           int32              `json:"venue_id"`
	VenueName         string             `json:"venue_name"`
	AddressFirstLine  string             `json:"address_first_line"`
	AddressSecondLine *string            `json:"address_second_line"`
	City              string             `json:"city"`
	Postcode          string             `json:"postcode"`
	Geom              interface{}        `json:"geom"`
	VenueWebsite      *string            `json:"venue_website"`
	Backline          []string           `json:"backline"`
	VenueComments     []string           `json:"venue_comments"`
	VenueDtUpdatedUtc pgtype.Timestamptz `json:"venue_dt_updated_utc"`
	Rating            float32            `json:"rating"`
}

func (q *Queries) GetSessionById(ctx context.Context, sessionID int32) (GetSessionByIdRow, error) {
	row := q.db.QueryRow(ctx, getSessionById, sessionID)
	var i GetSessionByIdRow
	err := row.Scan(
		&i.SessionID,
		&i.SessionName,
		&i.Venue,
		&i.Genres,
		&i.StartTimeUtc,
		&i.Interval,
		&i.DurationMinutes,
		&i.Description,
		&i.SessionWebsite,
		&i.DtUpdatedUtc,
		&i.VenueID,
		&i.VenueName,
		&i.AddressFirstLine,
		&i.AddressSecondLine,
		&i.City,
		&i.Postcode,
		&i.Geom,
		&i.VenueWebsite,
		&i.Backline,
		&i.VenueComments,
		&i.VenueDtUpdatedUtc,
		&i.Rating,
	)
	return i, err
}

const getSessionByIdAsGeoJSON = `-- name: GetSessionByIdAsGeoJSON :one
WITH t AS (
    SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.session_id = $1
    GROUP BY s.session_id, l.venue_id
)
SELECT public.ST_AsGeoJSON(t.*) FROM t
`

func (q *Queries) GetSessionByIdAsGeoJSON(ctx context.Context, sessionID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getSessionByIdAsGeoJSON, sessionID)
	var st_asgeojson interface{}
	err := row.Scan(&st_asgeojson)
	return st_asgeojson, err
}

const getSessionIdsByDate = `-- name: GetSessionIdsByDate :many
SELECT sessions_on_date FROM london_jam_sessions.sessions_on_date($1::date)
`

func (q *Queries) GetSessionIdsByDate(ctx context.Context, date pgtype.Date) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getSessionIdsByDate, date)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var sessions_on_date interface{}
		if err := rows.Scan(&sessions_on_date); err != nil {
			return nil, err
		}
		items = append(items, sessions_on_date)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionIdsByDateRange = `-- name: GetSessionIdsByDateRange :many
SELECT sessions_in_date_range FROM london_jam_sessions.sessions_in_date_range($1::date, $2::date)
`

type GetSessionIdsByDateRangeParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) GetSessionIdsByDateRange(ctx context.Context, arg GetSessionIdsByDateRangeParams) ([]interface{}, error) {
	rows, err := q.db.Query(ctx, getSessionIdsByDateRange, arg.StartDate, arg.EndDate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []interface{}
	for rows.Next() {
		var sessions_in_date_range interface{}
		if err := rows.Scan(&sessions_in_date_range); err != nil {
			return nil, err
		}
		items = append(items, sessions_in_date_range)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSessionsByBacklineAsGeoJSON = `-- name: GetSessionsByBacklineAsGeoJSON :one
WITH t AS (
    SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE l.backline @> $1
    GROUP BY s.session_id, l.venue_id
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

func (q *Queries) GetSessionsByBacklineAsGeoJSON(ctx context.Context, backline []string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByBacklineAsGeoJSON, backline)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateAndBacklineAsGeoJSON = `-- name: GetSessionsByDateAndBacklineAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    LEFT OUTER JOIN london_jam_sessions.sessions_on_date($1::date) d ON d.session_id = s.session_id
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE l.backline @> $2
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateAndBacklineAsGeoJSONParams struct {
	Date     pgtype.Date `json:"date"`
	Backline []string    `json:"backline"`
}

func (q *Queries) GetSessionsByDateAndBacklineAsGeoJSON(ctx context.Context, arg GetSessionsByDateAndBacklineAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateAndBacklineAsGeoJSON, arg.Date, arg.Backline)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateAndGenreAndBacklineAsGeoJSON = `-- name: GetSessionsByDateAndGenreAndBacklineAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    LEFT OUTER JOIN london_jam_sessions.sessions_on_date($1::date) d ON d.session_id = s.session_id
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $2
    AND l.backline @> $3
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateAndGenreAndBacklineAsGeoJSONParams struct {
	Date     pgtype.Date `json:"date"`
	Genres   []string    `json:"genres"`
	Backline []string    `json:"backline"`
}

func (q *Queries) GetSessionsByDateAndGenreAndBacklineAsGeoJSON(ctx context.Context, arg GetSessionsByDateAndGenreAndBacklineAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateAndGenreAndBacklineAsGeoJSON, arg.Date, arg.Genres, arg.Backline)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateAndGenreAsGeoJSON = `-- name: GetSessionsByDateAndGenreAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    LEFT OUTER JOIN london_jam_sessions.sessions_on_date($1::date) d ON d.session_id = s.session_id 
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $2 
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateAndGenreAsGeoJSONParams struct {
	Date   pgtype.Date `json:"date"`
	Genres []string    `json:"genres"`
}

func (q *Queries) GetSessionsByDateAndGenreAsGeoJSON(ctx context.Context, arg GetSessionsByDateAndGenreAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateAndGenreAsGeoJSON, arg.Date, arg.Genres)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateAsGeoJSON = `-- name: GetSessionsByDateAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating 
    FROM london_jam_sessions.sessions_on_date($1::date) d
    LEFT OUTER JOIN london_jam_sessions.jamsessions s ON d.session_id = s.session_id
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

func (q *Queries) GetSessionsByDateAsGeoJSON(ctx context.Context, date pgtype.Date) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateAsGeoJSON, date)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateRangeAndBacklineAsGeoJSON = `-- name: GetSessionsByDateRangeAndBacklineAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating 
    FROM london_jam_sessions.jamsessions s 
    LEFT OUTER JOIN london_jam_sessions.sessions_in_date_range($1::date, $2::date) d 
    ON d.session_id = s.session_id 
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE l.backline @> $3
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateRangeAndBacklineAsGeoJSONParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Backline  []string    `json:"backline"`
}

func (q *Queries) GetSessionsByDateRangeAndBacklineAsGeoJSON(ctx context.Context, arg GetSessionsByDateRangeAndBacklineAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateRangeAndBacklineAsGeoJSON, arg.StartDate, arg.EndDate, arg.Backline)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateRangeAndGenreAndBacklineAsGeoJSON = `-- name: GetSessionsByDateRangeAndGenreAndBacklineAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating 
    FROM london_jam_sessions.jamsessions s 
    LEFT OUTER JOIN london_jam_sessions.sessions_in_date_range($1::date, $2::date) d 
    ON d.session_id = s.session_id 
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $3
    AND l.backline @> $4
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateRangeAndGenreAndBacklineAsGeoJSONParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Genres    []string    `json:"genres"`
	Backline  []string    `json:"backline"`
}

func (q *Queries) GetSessionsByDateRangeAndGenreAndBacklineAsGeoJSON(ctx context.Context, arg GetSessionsByDateRangeAndGenreAndBacklineAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateRangeAndGenreAndBacklineAsGeoJSON,
		arg.StartDate,
		arg.EndDate,
		arg.Genres,
		arg.Backline,
	)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateRangeAndGenreAsGeoJSON = `-- name: GetSessionsByDateRangeAndGenreAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating 
    FROM london_jam_sessions.jamsessions s 
    LEFT OUTER JOIN london_jam_sessions.sessions_in_date_range($1::date, $2::date) d 
    ON d.session_id = s.session_id 
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $3
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateRangeAndGenreAsGeoJSONParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
	Genres    []string    `json:"genres"`
}

func (q *Queries) GetSessionsByDateRangeAndGenreAsGeoJSON(ctx context.Context, arg GetSessionsByDateRangeAndGenreAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateRangeAndGenreAsGeoJSON, arg.StartDate, arg.EndDate, arg.Genres)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByDateRangeAsGeoJSON = `-- name: GetSessionsByDateRangeAsGeoJSON :one
WITH t AS (
    SELECT d.dates, s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating 
    FROM london_jam_sessions.jamsessions s 
    LEFT OUTER JOIN london_jam_sessions.sessions_in_date_range($1::date, $2::date) d 
    ON d.session_id = s.session_id 
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    GROUP BY s.session_id, l.venue_id, d.dates
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByDateRangeAsGeoJSONParams struct {
	StartDate pgtype.Date `json:"start_date"`
	EndDate   pgtype.Date `json:"end_date"`
}

func (q *Queries) GetSessionsByDateRangeAsGeoJSON(ctx context.Context, arg GetSessionsByDateRangeAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByDateRangeAsGeoJSON, arg.StartDate, arg.EndDate)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByGenreAndBacklineAsGeoJSON = `-- name: GetSessionsByGenreAndBacklineAsGeoJSON :one
WITH t AS (
    SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $1
    AND l.backline @> $2
    GROUP BY s.session_id, l.venue_id
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(t.*)::json)
) FROM t
`

type GetSessionsByGenreAndBacklineAsGeoJSONParams struct {
	Genres   []string `json:"genres"`
	Backline []string `json:"backline"`
}

func (q *Queries) GetSessionsByGenreAndBacklineAsGeoJSON(ctx context.Context, arg GetSessionsByGenreAndBacklineAsGeoJSONParams) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByGenreAndBacklineAsGeoJSON, arg.Genres, arg.Backline)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getSessionsByGenreAsGeoJSON = `-- name: GetSessionsByGenreAsGeoJSON :one
WITH t AS (
    SELECT s.session_id, s.session_name, s.venue, s.genres, s.start_time_utc, s.interval, s.duration_minutes, s.description, s.session_website, s.dt_updated_utc, l.venue_id, l.venue_name, l.address_first_line, l.address_second_line, l.city, l.postcode, l.geom, l.venue_website, l.backline, l.venue_comments, l.venue_dt_updated_utc, coalesce(round(avg(rating), 2), 0.0)::real AS rating FROM london_jam_sessions.jamsessions s
    JOIN london_jam_sessions.venues l ON s.venue = l.venue_id
    LEFT OUTER JOIN london_jam_sessions.ratings r ON s.session_id = r.session
    WHERE s.genres @> $1
    GROUP BY s.session_id, l.venue_id
)
SELECT json_build_object(
    'type', 'FeatureCollection',
    'features', json_agg(public.ST_AsGeoJSON(*)::json)
) FROM t
`

func (q *Queries) GetSessionsByGenreAsGeoJSON(ctx context.Context, genres []string) ([]byte, error) {
	row := q.db.QueryRow(ctx, getSessionsByGenreAsGeoJSON, genres)
	var json_build_object []byte
	err := row.Scan(&json_build_object)
	return json_build_object, err
}

const getVenueById = `-- name: GetVenueById :one
SELECT venue_id, venue_name, address_first_line, address_second_line, city, postcode, geom, venue_website, backline, venue_comments, venue_dt_updated_utc FROM london_jam_sessions.venues
WHERE venue_id = $1
`

func (q *Queries) GetVenueById(ctx context.Context, venueID int32) (LondonJamSessionsVenue, error) {
	row := q.db.QueryRow(ctx, getVenueById, venueID)
	var i LondonJamSessionsVenue
	err := row.Scan(
		&i.VenueID,
		&i.VenueName,
		&i.AddressFirstLine,
		&i.AddressSecondLine,
		&i.City,
		&i.Postcode,
		&i.Geom,
		&i.VenueWebsite,
		&i.Backline,
		&i.VenueComments,
		&i.VenueDtUpdatedUtc,
	)
	return i, err
}

const getVenueByIdAsGeoJSON = `-- name: GetVenueByIdAsGeoJSON :one
WITH t AS (
    SELECT venue_id, venue_name, address_first_line, address_second_line, city, postcode, geom, venue_website, backline, venue_comments, venue_dt_updated_utc FROM london_jam_sessions.venues
    WHERE venue_id = $1
)
SELECT public.ST_AsGeoJSON(t.*) FROM t
`

func (q *Queries) GetVenueByIdAsGeoJSON(ctx context.Context, venueID int32) (interface{}, error) {
	row := q.db.QueryRow(ctx, getVenueByIdAsGeoJSON, venueID)
	var st_asgeojson interface{}
	err := row.Scan(&st_asgeojson)
	return st_asgeojson, err
}

const getVenueByName = `-- name: GetVenueByName :one
SELECT venue_id, venue_name, address_first_line, address_second_line, city, postcode, geom, venue_website, backline, venue_comments, venue_dt_updated_utc FROM london_jam_sessions.venues
WHERE venue_name = $1
`

func (q *Queries) GetVenueByName(ctx context.Context, venueName string) (LondonJamSessionsVenue, error) {
	row := q.db.QueryRow(ctx, getVenueByName, venueName)
	var i LondonJamSessionsVenue
	err := row.Scan(
		&i.VenueID,
		&i.VenueName,
		&i.AddressFirstLine,
		&i.AddressSecondLine,
		&i.City,
		&i.Postcode,
		&i.Geom,
		&i.VenueWebsite,
		&i.Backline,
		&i.VenueComments,
		&i.VenueDtUpdatedUtc,
	)
	return i, err
}

const insertJamSession = `-- name: InsertJamSession :one
INSERT INTO london_jam_sessions.jamsessions (
    session_name, venue, description, genres, start_time_utc, interval, duration_minutes, session_website
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8
) RETURNING session_id
`

type InsertJamSessionParams struct {
	SessionName     string             `json:"session_name"`
	Venue           int32              `json:"venue"`
	Description     string             `json:"description"`
	Genres          []string           `json:"genres"`
	StartTimeUtc    pgtype.Timestamptz `json:"start_time_utc"`
	Interval        string             `json:"interval"`
	DurationMinutes int16              `json:"duration_minutes"`
	SessionWebsite  *string            `json:"session_website"`
}

func (q *Queries) InsertJamSession(ctx context.Context, arg InsertJamSessionParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertJamSession,
		arg.SessionName,
		arg.Venue,
		arg.Description,
		arg.Genres,
		arg.StartTimeUtc,
		arg.Interval,
		arg.DurationMinutes,
		arg.SessionWebsite,
	)
	var session_id int32
	err := row.Scan(&session_id)
	return session_id, err
}

const insertSessionComment = `-- name: InsertSessionComment :one
INSERT INTO london_jam_sessions.comments (
    session, author, content
) VALUES (
    $1, $2, $3
) RETURNING comment_id
`

type InsertSessionCommentParams struct {
	Session int32  `json:"session"`
	Author  string `json:"author"`
	Content string `json:"content"`
}

func (q *Queries) InsertSessionComment(ctx context.Context, arg InsertSessionCommentParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertSessionComment, arg.Session, arg.Author, arg.Content)
	var comment_id int32
	err := row.Scan(&comment_id)
	return comment_id, err
}

const insertSessionRating = `-- name: InsertSessionRating :one
INSERT INTO london_jam_sessions.ratings (
    session, rating, comment
) VALUES (
    $1, $2, $3
) RETURNING rating_id
`

type InsertSessionRatingParams struct {
	Session int32  `json:"session"`
	Rating  *int16 `json:"rating"`
	Comment *int32 `json:"comment"`
}

func (q *Queries) InsertSessionRating(ctx context.Context, arg InsertSessionRatingParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertSessionRating, arg.Session, arg.Rating, arg.Comment)
	var rating_id int32
	err := row.Scan(&rating_id)
	return rating_id, err
}

const insertVenue = `-- name: InsertVenue :one
INSERT INTO london_jam_sessions.venues (
    venue_name, address_first_line, address_second_line, city, postcode, geom, venue_website, backline, venue_comments
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
) RETURNING venue_id
`

type InsertVenueParams struct {
	VenueName         string      `json:"venue_name"`
	AddressFirstLine  string      `json:"address_first_line"`
	AddressSecondLine *string     `json:"address_second_line"`
	City              string      `json:"city"`
	Postcode          string      `json:"postcode"`
	Geom              interface{} `json:"geom"`
	VenueWebsite      *string     `json:"venue_website"`
	Backline          []string    `json:"backline"`
	VenueComments     []string    `json:"venue_comments"`
}

func (q *Queries) InsertVenue(ctx context.Context, arg InsertVenueParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertVenue,
		arg.VenueName,
		arg.AddressFirstLine,
		arg.AddressSecondLine,
		arg.City,
		arg.Postcode,
		arg.Geom,
		arg.VenueWebsite,
		arg.Backline,
		arg.VenueComments,
	)
	var venue_id int32
	err := row.Scan(&venue_id)
	return venue_id, err
}

const updateJamSessionById = `-- name: UpdateJamSessionById :exec
UPDATE london_jam_sessions.jamsessions
SET
    session_name = coalesce($2, session_name),
    description = coalesce($3, description),
    genres = coalesce($4, genres),
    start_time_utc = coalesce($5, start_time_utc),
    interval = coalesce($6, interval),
    duration_minutes = coalesce($7, duration_minutes),
    session_website = coalesce($8, session_website)
WHERE session_id = $1
`

type UpdateJamSessionByIdParams struct {
	SessionID       int32              `json:"session_id"`
	SessionName     *string            `json:"session_name"`
	Description     *string            `json:"description"`
	Genres          []string           `json:"genres"`
	StartTimeUtc    pgtype.Timestamptz `json:"start_time_utc"`
	Interval        *string            `json:"interval"`
	DurationMinutes *int16             `json:"duration_minutes"`
	SessionWebsite  *string            `json:"session_website"`
}

func (q *Queries) UpdateJamSessionById(ctx context.Context, arg UpdateJamSessionByIdParams) error {
	_, err := q.db.Exec(ctx, updateJamSessionById,
		arg.SessionID,
		arg.SessionName,
		arg.Description,
		arg.Genres,
		arg.StartTimeUtc,
		arg.Interval,
		arg.DurationMinutes,
		arg.SessionWebsite,
	)
	return err
}

const updateVenueById = `-- name: UpdateVenueById :exec
UPDATE london_jam_sessions.venues
SET -- see https://docs.sqlc.dev/en/latest/howto/named_parameters.html#nullable-parameters
    venue_name = coalesce($2, venue_name),
    address_first_line = coalesce($3, address_first_line),
    address_second_line = coalesce($4, address_second_line),
    city = coalesce($5, city),
    postcode = coalesce($6, postcode),
    geom = coalesce($7, geom),
    venue_website = coalesce($8, venue_website),
    backline = coalesce($9, backline),
    venue_comments = coalesce($10, venue_comments)
WHERE venue_id = $1
`

type UpdateVenueByIdParams struct {
	VenueID           int32       `json:"venue_id"`
	VenueName         *string     `json:"venue_name"`
	AddressFirstLine  *string     `json:"address_first_line"`
	AddressSecondLine *string     `json:"address_second_line"`
	City              *string     `json:"city"`
	Postcode          *string     `json:"postcode"`
	Geom              *geom.Point `json:"geom"`
	VenueWebsite      *string     `json:"venue_website"`
	Backline          []string    `json:"backline"`
	VenueComments     []string    `json:"venue_comments"`
}

func (q *Queries) UpdateVenueById(ctx context.Context, arg UpdateVenueByIdParams) error {
	_, err := q.db.Exec(ctx, updateVenueById,
		arg.VenueID,
		arg.VenueName,
		arg.AddressFirstLine,
		arg.AddressSecondLine,
		arg.City,
		arg.Postcode,
		arg.Geom,
		arg.VenueWebsite,
		arg.Backline,
		arg.VenueComments,
	)
	return err
}
